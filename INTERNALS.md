# The ZZ build system

## Organization of ZZ packages

Package management works somewhat like in Go.

The ZZPATH directory - which defaults to `$HOME/zz` - holds the source code, object files, static libraries and binary executables of all ZZ packages available on the system:

- `$ZZPATH/src/<package>`: source code (*.lua, *.c)
- `$ZZPATH/obj/<package>`: object files (*.lo, *.o)
- `$ZZPATH/lib/<package>`: static libraries (*.a)
- `$ZZPATH/bin/<package>`: executables
- `$ZZPATH/bin`: symlinks to public executables of all local packages (this directory is expected to be on PATH)

A package identifier `<package>` typically identifies the official Git repository of the package. For example, the package identifier for the ZZ core library is `github.com/cellux/zz`, thus the source code for the package is kept at `$ZZPATH/src/github.com/cellux/zz`.

Within a package source directory, each Lua source file defines a *module* of the package. For example, `async.lua` inside the `github.com/cellux/zz` package identifies the `github.com/cellux/zz/async` module. If a module named `M.lua` has an associated C file `M.c`, then the latter is compiled together with the Lua module and the resulting object file is added to the package's static library. The C file typically extends the corresponding Lua module with C functions and variables which are accessible from the Lua side through the LuaJIT FFI.

## Compilation

- *.lua -> *.lo
- *.c -> *.o

Lua modules are compiled into bytecode and wrapped into ELF object files with a .lo extension. The bytecode inside the object file is marked with the symbol `luaJIT_BC_zz_<hash>`, where <hash> is the SHA1 hash of the fully qualified module name (i.e. `<package>/<module>`). For instance, module `gl` of the `github.com/cellux/zz_gl` package can be looked up by the symbol `luaJIT_BC_zz_a531170c0bc6bf9a100a23b0ae10997a80b8edf2`.

Compiled modules (*.lo and *.o files) of a package are collected into a static library at `$ZZPATH/lib/<package>/lib<basename>.a` where `<basename>` denotes the basename of the package directory. This static library is then linked (using `--whole-archive`) into any executable which depends on the package. 

## Importing modules

In ZZ programs the `require` function can be used to import modules from external packages.

Each package has its own `require` function which resolves module M using the following algorithm:

1. If M is a fully qualified module name (`<package>/<module>`), return the corresponding module (unambigious match)
2. If M is a short module name (`<module>`):
   a. Look for module M exported by the current package
   b. Look for module M exported by the ZZ core library (`github.com/cellux/zz`)
   c. Look for module M exported by any of the current package's explicit dependencies (imports)
   d. Look for native Lua module M

Two consequences of the above algorithm:

1. it is usually unnecessary to use fully qualified names in `require` statements
2. the order of dependencies in the package descriptor (see below) determines where a particular module is found first

## Package descriptor

Each package has a *package descriptor* in the file `$ZZPATH/src/<package>/package.lua`.

The package descriptor is an ordinary module like any other, it can be required as `<package>/package`.

It contains the following information about the package:

- fully qualified package name (package)
- imported packages (imports)
- exported modules (exports)
- C dependencies of exported modules (depends)
- native dependencies of the package (native)
- linker flags (ldflags)
- VFS mount points (mounts)
- list of apps generated by the package (apps)
- list of apps which shall be publicly installed (install)
