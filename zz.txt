# The ZZ build system

## Organization of ZZ packages

Package management works somewhat like in Go.

The ZZPATH directory - which defaults to `$HOME/zz` - holds the source code, object files, static libraries and binary executables of all ZZ packages available on the system:

- `$ZZPATH/src/<package>`: source code (*.lua, *.c)
- `$ZZPATH/obj/<package>`: object files (*.lo, *.o)
- `$ZZPATH/lib/<package>`: static libraries (*.a)
- `$ZZPATH/bin/<package>`: executables
- `$ZZPATH/bin`: globally installed executables of all packages (this directory is expected to be on PATH)

A package identifier `<package>` typically identifies the official Git repository of the package. For example, the package identifier for the ZZ core library is `github.com/cellux/zz`, thus the source code for the package is kept at `$ZZPATH/src/github.com/cellux/zz`.

Within a package source directory, each Lua source file defines a *module* of the package. For example, `async.lua` inside the `github.com/cellux/zz` package identifies the `github.com/cellux/zz/async` module. If a module named `M.lua` has an associated C file `M.c`, then the latter is compiled together with the Lua module and the resulting object file is added to the package's static library. The C file extends the corresponding Lua module with C functions and variables which are accessible from the Lua side through the LuaJIT FFI.

## Compilation

- *.lua -> *.lo
- *.c -> *.o

Lua modules are compiled into bytecode and added to ELF object files with a .lo extension. The bytecode inside the object file is marked with the symbol `luaJIT_BC_zz_<hash>`, where <hash> is the SHA1 hash of the fully qualified module name (i.e. `<package></module>`). For instance, module `gl` of the `github.com/cellux/zz_gl` package can be looked up by the symbol `luaJIT_BC_zz_a531170c0bc6bf9a100a23b0ae10997a80b8edf2`.

Compiled modules (*.lo and *.o files) of a package are collected into a static library which is saved to `$ZZPATH/lib/<package>/lib<basename>.a` and linked (using `--whole-archive`) into any executable which depends on the package.

## Importing modules

In ZZ programs the `require` function can be used to import modules from external packages.

When a program executes `require(name)`, the engine goes through the following steps to find the module:

1. prepend the name of the current package to `/name` and lookup the resulting fully qualified module name (this finds modules of the current package)
2. for each declared dependency: prepend the name of the dependency package to `/name` and lookup the resulting fully qualified module name (this finds modules in external packages)
3. lookup using the non-mangled `name`

The `github.com/cellux/zz` package is an implicit dependency of all packages.

As a consequence of the above algorithm, it is usually not necessary to use fully qualified names in `require` statements.

## Package descriptor

Every package has a *package descriptor* in the file `$ZZPATH/src/<package>/ZZMakefile`.

This file contains the following information about the package:

- package name
- dependencies
- build instructions
- libraries and binary executables generated by the package

## Command line interface

### zz init

```
zz init <package>
```

Create a new package at `$ZZPATH/src/<package>`, populate it with a package descriptor (`ZZMakefile`) and a single module (`main.lua`) which defines the main function of the application.

### zz download

```
zz download <package>
```

Clone the Git repository at <package> (which ought to be a Git URL) to `$ZZPATH/src/<package>`.

### zz build

```
zz build [<package>]
```

Compilation process for package P:

```
for every Lua file M.lua except *_test.lua:
  compile M.lua into $ZZPATH/obj/P/M.lo
  set the symbol of the bytecode inside M.lo to `luaJIT_BC_zz_<hash>` where <hash> is the SHA1 sum of the string P/M
  if there is a corresponding C support file M.c:
    compile M.c into $ZZPATH/obj/P/M.o
let L = last component (basename) of package name
collect the resulting M.lo and M.o files into $ZZPATH/lib/P/libL.a
```

```
for each key-value pair M->B in the `bin` map defined in ZZMakefile:
  generate a C stub which requires M after bootstrap
  link it with the package archive and all dependencies using ld --whole-archive
  output the resulting binary to $ZZPATH/bin/P/B
```

### zz test

```
zz test [<package>] [<module>...]
```

Testing process for package P:

```
for every Lua file M_test.lua:
  compile M_test.lua into $ZZPATH/obj/P/M_test.lo
  set the symbol of the bytecode inside M_test.lo to `luaJIT_BC_zz_<hash>` where <hash> is the SHA1 sum of the string P/M_test
  if there is a corresponding C support file M_test.c:
    compile M_test.c into $ZZPATH/obj/P/M_test.o
let L = last component (basename) of package name
collect the resulting M_test.lo and M_test.o files into $ZZPATH/lib/P/libL_test.a
generate a C stub with a test runner which runs all tests after bootstrap
link it with the package archive and all dependencies using ld --whole-archive
output the resulting binary to $ZZPATH/bin/P/L_test
execute $ZZPATH/bin/P/L_test
```

### zz run

```
zz run <module>
```

This command can be used to execute any module of a package as an application.

It's similar to build, with the following differences:

1. generates a single C stub which requires the specified module
2. the resulting executable is written into a temporary directory and removed after execution

### zz install

```
zz install <package>
```

Install process for package P:

```
for each element B in the `install` array defined in ZZMakefile:
  copy $ZZPATH/bin/P/B to $ZZPATH/bin
```

### zz get

```
zz get <package>
```

Equivalent to:

```
zz download <package>
for each dependency P:
  zz get P
zz build <package>
zz install <package>
```

Example:

```
zz get github.com/zzlua/gl
```
